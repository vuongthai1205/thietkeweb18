"use strict";

exports.__esModule = true;
exports.default = void 0;

var _react = require("react");

var _reactDom = require("react-dom");

var _constants = require("./constants");

var useInViewport = function useInViewport(target, options, config, props) {
    if (options === void 0) {
        options = _constants.defaultOptions;
    }

    if (config === void 0) {
        config = _constants.defaultConfig;
    }

    if (props === void 0) {
        props = _constants.defaultProps;
    }

    var {
        onEnterViewport,
        onLeaveViewport
    } = props;
    var [, forceUpdate] = (0, _react.useState)();
    var observer = (0, _react.useRef)();
    var inViewportRef = (0, _react.useRef)(false);
    var intersected = (0, _react.useRef)(false);
    var enterCountRef = (0, _react.useRef)(0);
    var leaveCountRef = (0, _react.useRef)(0);

    function startObserver(_ref) {
        var {
            observerRef
        } = _ref;
        var targetRef = target.current;

        if (targetRef) {
            var node = (0, _reactDom.findDOMNode)(targetRef);

            if (node) {
                observerRef == null ? void 0 : observerRef.observe(node);
            }
        }
    }

    function stopObserver(_ref2) {
        var {
            observerRef
        } = _ref2;
        var targetRef = target.current;

        if (targetRef) {
            var node = (0, _reactDom.findDOMNode)(targetRef);

            if (node) {
                observerRef == null ? void 0 : observerRef.unobserve(node);
            }
        }

        observerRef == null ? void 0 : observerRef.disconnect();
        observer.current = null;
    }

    function handleIntersection(entries) {
        var entry = entries[0] || {};
        var {
            isIntersecting,
            intersectionRatio
        } = entry;
        var isInViewport = typeof isIntersecting !== 'undefined' ? isIntersecting : intersectionRatio > 0; // enter

        if (!intersected.current && isInViewport) {
            intersected.current = true;
            onEnterViewport == null ? void 0 : onEnterViewport();
            enterCountRef.current += 1;
            inViewportRef.current = isInViewport;
            forceUpdate(isInViewport);
            return;
        } // leave


        if (intersected.current && !isInViewport) {
            intersected.current = false;
            onLeaveViewport == null ? void 0 : onLeaveViewport();

            if (config.disconnectOnLeave && observer.current) {
                // disconnect obsever on leave
                observer.current.disconnect();
            }

            leaveCountRef.current += 1;
            inViewportRef.current = isInViewport;
            forceUpdate(isInViewport);
        }
    }

    function initIntersectionObserver(_ref3) {
        var {
            observerRef
        } = _ref3;

        if (!observerRef) {
            observer.current = new IntersectionObserver(handleIntersection, options);
            return observer.current;
        }

        return observerRef;
    }

    (0, _react.useEffect)(() => {
        var observerRef = observer.current; // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API

        observerRef = initIntersectionObserver({
            observerRef
        });
        startObserver({
            observerRef
        });
        return () => {
            stopObserver({
                observerRef
            });
        };
    }, [target.current, options, config, onEnterViewport, onLeaveViewport]);
    return {
        inViewport: inViewportRef.current,
        enterCount: enterCountRef.current,
        leaveCount: leaveCountRef.current
    };
};

var _default = useInViewport;
exports.default = _default;